<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //为什么需要块级作用域
       /*  //1.内层变量可能会覆盖外层变量
        let tmp = new Date();
        function f(){
            console.log(tmp);
            if(false){
                let tmp = 'hello wrold';
            }
        }
        f() undefined
        //变量提升的原因，导致内层tmp变量覆盖了外层的tmp变量
        
        */

        //2.用来计数的循环变量泄露为全局变量
       /*  var s = 'hello';
        for(var i = 0; i < s.length; i++){
            console.log(s[i])
        }
        console.log(i) //5 
        //循环结束后，变量没有消失，泄露成立全局变量
        */

        //const 声明一个只读的常量，一旦声明，常量的值就不能改变。
        /* const PI = 3.1415;
        PI = 3; 报错*/
       /*  //const 一旦声明，就必须立即初始化，不能留到以后赋值。
        const foo; 报错 只声明不赋值，就会报错
        const的作用域与let命令相同：只在声明所在的块级作用域内有效
        if(true){
            const MAX = 5;
        }
        console.log(MAX)
        const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。、
        if(true){
            console.log(max);
            const max =10; //报错
        }

        //const声明的常量，也与let一样不可重复声明
        var message = "hello";
        let age = 25;
        const message = "goodbye"; //报错
        const age = 30; //报错
        */

        //const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
        /* //如果真的想将对象冻结，应该使用Object.freeze方法
        const foo = Object.freeze({})
        //常规模式时，下面一行不起作用
        //严格模式时，该行会报错
        foo.prop = 123  */


       /*  //将对象彻底冻结的函数
        var constantize = (obj) => {
            Object.freeze(obj);
            Object.keys(obj).forEach( (key, i ) => {
                if(typeof obj[key] === 'object'){
                    constantize( obj[key]);
                }
            })
        } */
        //ES6声明变量的六种方法
        //var命令 function命令 let命令 const命令 import命令 class命令


        //顶层对象的属性
        //在浏览器环境指的是window对象，在node指的是global对象。
        //ES5之中，顶层对象的属性与全局变量是等价的
    </script>
</body>
</html>